# SPDX-License-Identifier: GPL-2.0-or-later
# Copyright (C) 2025 Texas Instruments Incorporated - https://www.ti.com/
#

source [find bitsbytes.tcl]
source [find mem_helper.tcl]

# Device info
if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME cc27xx
}

if { [info exists CPUTAPID] } {
	set _DAP_TAPID $CPUTAPID
} else {
	set _DAP_TAPID 0x4ba00477
}

if { [info exists DAP_SWD_ID] } {
	set _DAP_SWD_ID $DAP_SWD_ID
} else {
	set _DAP_SWD_ID 0x2ba01477
}

source [find target/swj-dp.tcl]

# Declare a new DAP when using Serial Wire (SWD)
set _DAP_ID $_DAP_SWD_ID

# Create and add DAP and target
swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_DAP_ID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu -switch-thru-dormant

# Adding cpu target
set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -dap $_CHIPNAME.dap

set _FLASHNAME $_CHIPNAME.flash

# Configure flash banks for CC27xx device
# CCFG section (Configuration and Control)
flash bank $_FLASHNAME.ccfg cc27xx 0x4e020000 0x00000800 0 0 $_TARGETNAME

# SCFG section (Secure Configuration)
flash bank $_FLASHNAME.scfg cc27xx 0x4e040000 0x00000400 0 0 $_TARGETNAME

# # Main flash memory
flash bank $_FLASHNAME.main cc27xx 0x00000000 0x00000000 0 0 $_TARGETNAME

# define the type of reset that should be applied
reset_config srst_only combined srst_nogate

$_TARGETNAME configure -event gdb-attach {
	echo "Debugger attaching: Halting Execution"
	halt 0
	#$_TARGETNAME arp_examine
	wait_halt
}

$_TARGETNAME configure -event gdb-detach {
	echo "Debugger detaching: resuming Execution"
	resume
}

 #examine-start gets called after target configs are initialized but before openOCD connects to CPU
$_TARGETNAME configure -event examine-start {
	dap init
	echo "examine-start"
}

$_TARGETNAME configure -event examine-fail {
	echo "examine fail"
}

$_TARGETNAME configure -event examine-end {
	echo "examine-end"
}

proc cc-lpf3-reset-init {} {
	echo "reset-init"
}

set program_state "none"

proc ocd_process_reset_inner { MODE } {
	global program_state
	set targets [target names]

	# If this target must be halted...
	switch $MODE {
		halt -
		init {
			set halt 1
		}
		run {
			set halt 0
		}
		default {
			return -code error "Invalid mode: $MODE, must be one of: halt, init, or run";
		}
	}

	if { $MODE eq "init" && $program_state eq "none" } {
		# assert reset pin; equivalent to power-on reset
		adapter assert srst
		# drop sRST Pin after at least for few ms
		sleep 5
		adapter deassert srst
		if { $MODE eq "init" } {
			# send DORMANT to SWD Sequence
			set program_state "flash"
		}
		# stabilize
		sleep 60
		set timeout 10000
	}

	if { $MODE eq "halt" && $program_state eq "halt_and_boot_app" } {
		# Reset the device
		adapter assert srst
		# drop sRST Pin after at least for few ms
		sleep 5
		adapter deassert srst

		# Wait for stabilization
		sleep 60

		dap init

		# Wait for the device to enter SACI mode
		sleep 100

		# Calling the cc27xx reset_halt command handler to exit SACI and halt
		if { [cc27xx reset_halt 0] eq 0 } {
			poll
			halt 0
			wait_halt
		} else {
			return -code error "Error: Failed to reset and halt the device"
		}

		# Write R3 0 to exit from debug probe loop
		reg r3 0x00000000
	}

	if { $MODE eq "halt" && $program_state eq "halt_and_reset_flash"  } {
		# No delay required here as we are waiting while reading RXCTL Register
		# Reading SCB_VTOR
		set read_vt [mrw 0xE000ED08]
		set read_pc [reg pc]
		echo "pc $read_pc"
		# Write R3 0 to exit from debug probe loop
		reg r3 0x00000000
		set program_state "halt_and_boot_app"
		sleep 50
		set read_r3 [reg r3]
		echo "r3 $read_r3"
		dap init
	}

	# Handle Flash and Run
	if { $MODE eq "halt" && $program_state eq "flash"  } {
		adapter assert srst
		# drop sRST Pin after at least for few ms
		sleep 5
		adapter deassert srst
		# stabilize
		sleep 60
		set program_state "halt_and_reset_flash"
		cc27xx reset_halt 0
		halt 0
		poll
		wait_halt
	}

	# Handle Flash and Run
	if { $MODE eq "run" && $program_state eq "flash" } {
		adapter assert srst
		# drop sRST Pin after at least for few ms
		sleep 5
		adapter deassert srst
		# stabilize
		sleep 60
		cc27xx reset_run 0
		set program_state "none"
	}
	if { $MODE eq "init" } {
		#Added to make sure CPU registers are read with correct values
		sleep 60
		dap init
	}
}

# Execute a SACI command.
# Parameters:
# 	command: The value representing the SACI command to execute
# 	args: List of parameter words
# Returns:
# 	The value contained in the RXD register after the execution of the requested SACI command
proc cc27xx_execute_saci_command {command args} {
	echo "In Func : cc27xx_execute_saci_command"
	# Read TXCTL (0x204) (for debug purposes)
	set txctl [$::_CHIPNAME.dap apreg 2 0x4]
	echo "txctl: $txctl"

	# Read RXCTL (0x20c) (for debug purposes)
	set rxctl [$::_CHIPNAME.dap apreg 2 0xc]
	echo "rxctl: $rxctl"

	# Set bit 1 of TXCTL (0x204): CMD_START
	# Indicates that TXD contains the first word of a command
	$::_CHIPNAME.dap apreg 2 0x4 0x2

	# Set TXD (0x200)
	$::_CHIPNAME.dap apreg 2 0x0 $command

	# Read TXCTL (0x204) (for debug purposes)
	set txctl [$::_CHIPNAME.dap apreg 2 0x4]
	echo "txctl: $txctl"

	# Clear TXCTL (0x204)
	$::_CHIPNAME.dap apreg 2 0x4 0x0

	# Write additional parameter words
	foreach {param_word} $args {
		# echo "param_word: $param_word"
		$::_CHIPNAME.dap apreg 2 0x0 $param_word
	}

	# Wait for the command to finish the execution
	# Probably this delay could be optimized
	sleep 1000

	# Read RXCTL (0x20c) (for debug purposes)
	set rxctl [$::_CHIPNAME.dap apreg 2 0xc]
	echo "rxctl: $rxctl"

	# Read RXD (0x208) (to retrieve the response, if relevant)
	set rxd [$::_CHIPNAME.dap apreg 2 0x8]
	echo "rxd  : $rxd"

	return $rxd
}
